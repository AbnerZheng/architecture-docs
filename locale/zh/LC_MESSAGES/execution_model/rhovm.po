# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, RChain Cooperative
# This file is distributed under the same license as the RChain Architecture
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: RChain Architecture 0.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-18 16:26+0800\n"
"PO-Revision-Date: 2018-01-30 00:55+0800\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Last-Translator: \n"
"Language-Team: \n"
"X-Generator: Poedit 2.0.5\n"
"Language: zh\n"

#: ../../execution_model/rhovm.rst:5
msgid "Execution Model"
msgstr "执行模型"

#: ../../execution_model/rhovm.rst:8
msgid "Overview"
msgstr "概论"

#: ../../execution_model/rhovm.rst:10
msgid ""
"Each instance of the **Rho Virtual Machine** (RhoVM) maintains an "
"environment that repeatedly applies the low-level rho-calculus reduction "
"rule, expressed in the high-level Rholang contracting language, to the "
"elements of a persistent key-value data store [#]_. The \"state\" of RhoVM "
"is analogous to the state of the blockchain."
msgstr ""
"每一个 **Rho虚拟机** （RhoVM）实例都维护着一个环境，该环境重复应用底层Rho演算"
"归约规则于持久性键值数据库中的元素，这些规则在高级Rholang合约语言中表达 "
"[#]_。 RhoVM的“状态”类似于区块链的状态。"

#: ../../execution_model/rhovm.rst:18
msgid "*Figure - RhoVM as a back-to-back key-value store and execution engine*"
msgstr "*图 - RhoVM作为联排式键值存储和执行引擎*"

#: ../../execution_model/rhovm.rst:21
msgid ""
"The execution of a contract affects the *environment* and *state* of an "
"instance of RhoVM. In this case, the usage of the term \"environment\" does "
"not refer to the execution environment exclusively, but to the configuration "
"of the key-value structure. Environment and state are the mapping of names "
"to locations in memory, and of locations in memory to values, respectively. "
"Variables directly reference locations, which means that environment is "
"equivalently a mapping of names to variables. A program typically modifies "
"one or both of these associations at runtime. Environmental modifications "
"occur with the lexical scoping rules of Rholang, and values may be simple or "
"complex i.e. primitive values or complete programs."
msgstr ""
"合约的执行会影响RhoVM实例的 *环境* 和 *状态* 。在这种情况下，所谓的“环境”不仅"
"指的是执行环境，也包括键值结构的配置。环境和状态分别是名称到内存中的位置以及"
"内存中的位置到值的映射。变量直接引用内存中的位置，这意味着环境相当于命名到变"
"量的映射。程序通常在运行时修改这些关联中的一个或两个。环境的改变伴随着Rholang"
"的词法作用域规则发生，它的值可能是简单或复杂，比如原始值或完整程序。"

#: ../../execution_model/rhovm.rst:29
msgid "*Figure - Two-stage binding from names to values*"
msgstr "*图 — 从名称到值的两阶段绑定*"

#: ../../execution_model/rhovm.rst:32
msgid ""
"RhoVM operates against a key-value data store. **A state change of RhoVM is "
"realized by an operation that modifies which key maps to what value.** "
"Since, like Rholang, RhoVM is derived from the rho-calculus model of "
"computation, that operation is the low-level rho-calculus reduction rule. "
"Effectively, the reduction rule, known as the \"COMM\" rule, is a "
"substitution that defines a computation :code:`P` to be performed if a new "
"value is observed at a key. A key is analogous to a name in that it "
"references a location in memory which holds the value being substituted. In "
"the following example, :code:`key` is a key and :code:`val` is the value "
"being substituted:"
msgstr ""
"RhoVM针对键值数据库操作。**RhoVM的状态变化是通过修改键映射到值关系的操作来实"
"现的** 因为像Rholang一样，RhoVM是从Rho演算计算模型中衍生的，那么操作就是底层"
"的rho演算归约规则。卓有成效地，被称为“COMM”的归约规则是一种替代方案，它定义了"
"如果在一个键上观察到新值，则要执行 :code:`P`。键类似于一个名字，在该名字中它"
"引用内存中持有将被替换的值的地址。在下面的例子中，:code:`key` 是一个键， :"
"code:`val` 是被替换的值："

#: ../../execution_model/rhovm.rst:41
msgid ""
"Barring consensus, this is the computational model of a concurrent protocol "
"that stores a contract on the blockchain. On some thread, the output "
"process :code:`key!` stores the code of a contract :code:`@Q` at the "
"location denoted by :code:`key`. On another thread running concurrently, the "
"input process :code:`for ( val <- key )P` waits for a new value :code:`val` "
"to appear at :code:`key`. When some :code:`val` appears at :code:`key`, in "
"this case :code:`@Q`, :code:`P` is executed in an environment where :code:"
"`@Q` is substituted for every occurrance of :code:`val`. This operation "
"modifies the value that :code:`key` references i.e. :code:`key` previously "
"mapped to a generic :code:`val` but now it maps to the code of a contract :"
"code:`@Q`, which qualifies a reduction as a state transition of the RhoVM."
msgstr ""
"除了共识之外，这就是在区块链上存储合约的并发协议的计算模型。 在某个线程上，输"
"出进程 :code:`key!`，将合约 :code:`@Q` 的代码存储在由 :code:`key` 指示的位"
"置。在另一个并发运行的线程上，输入进程 :code:`for ( val <- key )P` 等待一个新"
"的 :code:`val` 出现在 :code:`key` 上。 当在 :code:`key` 上出现一些 :code:"
"`val` 时，在这种情况下， :code:`@Q` ， :code:`P` 将在一个环境中被执行，在该环"
"境中，出现的每个 :code:`val` 都将被替换为 :code:`@Q`。该操作修改了 :code:"
"`key` 所引用的值，比如说，:code:`key` 先前映射到一般的 :code:`val`， 而现在映"
"射到合约 :code:`@Q` 的代码，有资格作为RhoVM的状态转换的归约。"

#: ../../execution_model/rhovm.rst:52
msgid ""
"The synchronization of an input and output process at :code:`key` is the "
"event that triggers a state transition of RhoVM. At first glance, the output "
"process, which stores the contract :code:`@Q` to the location denoted by :"
"code:`key`, appears to constitute a state transition in itself. However, the "
"rho-calculus reduction semantics have an *observability* requirement. For "
"any future computation :code:`P` to occur, the reduction rule requires that "
"the input process :code:`for ( val <- key) P` *observes* the assignment at :"
"code:`key`. This is because only the input term defines future computation, "
"which means that the output term alone is computationally insignificant. "
"Therefore, no *observable* state transition occurs until the input and "
"output terms synchronize at :code:`key`. This obvservability requirement is "
"enforced at compile-time to prevent DDoS attacks by repeated output :code:"
"`key!(@Q)` invocation."
msgstr ""
"在 :code:`key` 上的输入和输出进程的同步是通过触发RhoVM的状态转换的事件来实"
"现。乍一看，将合约 :code:`@Q` 存储到由 :code:`key` 所表示的位置的输出进程，本"
"身构成一个状态转换。但是，Rho演算归约语义要求具有 **可观测性**。对于任何未来"
"将发生的计算 :code:`P`，归约规则要求输入进程 :code:`for ( val <- key) P`，**"
"观察到** 在 :code:`key` 上的赋值。这是因为只有输入项定义未来的计算，也就是说"
"输出项本身在计算上是不重要的。 因此，直到输入和输出项在 :code:`key` 上同步之"
"后，才会出现 **可观察** 的状态转换。这个可观测性要求在编译时被强制执行，以防"
"止通过重复调用输出 :code:`key!(@Q)` 的DDoS攻击。"

#: ../../execution_model/rhovm.rst:54
msgid ""
"It has been demonstrated that an application of the rho-calculus reduction "
"rule, to a data element of a key-value data store, constitutes a state "
"transition of an instance of the RhoVM. The goal, however, is to verify and "
"maintain every state transition that is specified by any contract to ever "
"execute on an instance of the RhoVM. This means that the configuration "
"history of the key-value data store must be maintained through modification, "
"hence it being a *persistent* data structure. Therefore, each key must map "
"to the verified history of reductions to occur at that location:"
msgstr ""
"已经证明，将rho演算归约规则应用于键值数据存储的数据元素上，构成了RhoVM实例上"
"的状态转换。但是，其目的是为了验证和维护实例上所执行的每个合约指定的所有状态"
"转换。这意味着键值数据存储的配置历史记录必须通过修改来维护，因此它是一个可持"
"久化的数据结构。 所以，每个key必须映射到在该位置发生的已验证的归约历史记录："

#: ../../execution_model/rhovm.rst:62
msgid "*Figure - Reduction/transaction history of a location in memory*"
msgstr "*图 - 内存中某个位置的归约/转换历史*"

#: ../../execution_model/rhovm.rst:65
msgid ""
"Each key maps to a list of reductions which is, in fact, the \"transaction "
"history\" of an address. The history of transactions :code:`{ for(val1 <- "
"keyn).P1 | keyn!(@Q1), ... , for(valn <- keyn).Pn | keyn!(@Qn) } -> { P1{@Q1/"
"val1}, ... , Pn{@Qn/valn} }` denotes the modifications that have been made "
"to the contract :code:`@Q`, where :code:`@Qn` is the most current version in "
"store. It is important to recognize that this scheme is a top-level "
"transaction on the RChain platform. The messages being passed are contracts "
"themselves, which most often occurs in client-system, or system-system "
"interactions. However, each contract :code:`@Q` may, itself, execute many "
"lower-level transactions on simpler values."
msgstr ""
"每个键映射到一个归约列表，它实际上是某个地址的“事务历史”。 事务 :code:"
"`{ for(val1 <- keyn).P1 | keyn!(@Q1), … , for(valn <- keyn).Pn | keyn!"
"(@Qn) } -> { P1{@Q1/val1}, … , Pn{@Qn/valn} }` 的历史意味着合约 :code:`@Q` 已"
"经做了的修改，其中 :code:`@Qn` 是仓库中的最近版本。认识到这个方案是RChain平台"
"上的最顶层事务是非常重要的。传递的消息本身就是合约，这通常发生在客户系统或系"
"统间交互中。 但是，每个合约 :code:`@Q` 本身也可以在更简单的值上执行许多底层事"
"务。"

#: ../../execution_model/rhovm.rst:67
msgid ""
"After a transaction/reduction is applied, it is subjected to consensus. "
"Consensus verifies that the transaction history, :code:`{ for(val1 <- keyn)."
"P1 | keyn!(@Q1) … for(valn <- keyn).Pn | keyn!(@Qn) }`, of :code:`keyn`, is "
"consistently replicated across all nodes running that instance of RhoVM. "
"Once transaction histories are verified, the most recent transaction is "
"added to the transaction history. The same consensus protocol is applied "
"over the range of keys :code:`{ key1 -> val1 … keyn -> valn }` as "
"transactions are committed to those locations."
msgstr ""
"在事务/归约应用之后，就要达成共识。共识验证在 :code:`keyn` 上的事务历史，:"
"code:`{ for(val1 <- keyn).P1 | keyn!(@Q1) … for(valn <- keyn).Pn | keyn!"
"(@Qn) }` ，在所有运行RhoVM实例的节点上一致性地复制。一旦事务历史被验证，最近"
"的事务就被添加到事务历史中。 当事务被提交到这些位置时，相同的共识协议会应用到"
"一系列的键 :code:`{ key1 -> val1 … keyn -> valn }`。"

#: ../../execution_model/rhovm.rst:69
msgid ""
"By extension, transaction blocks represent sets of reductions that have been "
"applied to elements of the persistent key-value store, and transaction "
"histories represent verifiable snapshots of the state configurations and "
"transitions of an instance of the Rho Virtual Machine. Note that the "
"consensus algorithm is applied if, and only if, node operators propose "
"conflicting reduction histories."
msgstr ""
"拓展一下，事务块表示已经应用到持久化键值存储中元素的归约集合，而事务历史表示"
"一个Rho虚拟机实例的状态配置和转换的可验证快照。请注意，当且仅当节点上提出冲突"
"的归约历史时，共识算法才会被应用。"

#: ../../execution_model/rhovm.rst:71
msgid "To summarize:"
msgstr "总结："

#: ../../execution_model/rhovm.rst:73
msgid ""
"RhoVM is the composition of the rho-calculus reduction semantics, expressed "
"in Rholang, and a persistent key-value data store."
msgstr ""
"RhoVM虚拟机由Rholang表达的Rho演算归约规则，以及一个持久化的键值数据存储组成。"

#: ../../execution_model/rhovm.rst:74
msgid ""
"The rho-calculus reduction rule substitutes the value at a key for another "
"value, where a named channel corresponds to a key, and values may be simple "
"or complex."
msgstr ""
".Rho演算归约规则将一个键的值替换为另一个值，其中一个命名频道对应于一个键，并"
"且值可以是简单或复杂的。"

#: ../../execution_model/rhovm.rst:75
msgid ""
"Substitutions are transactions, which manifest as differences in the "
"bytecode stored at a key. The accurate replication of those bytecode "
"differences, across all nodes operating that instance of RhoVM, is verified "
"via the consensus algorithm."
msgstr ""
"替换就是事务，表现为存储在键中的字节码的差异。这些字节码差异在所有运行该RhoVM"
"实例的结点上的精确复制，是通过共识算法验证的。"

#: ../../execution_model/rhovm.rst:77
msgid ""
"The RhoVM \"Execution Environment\" will later be introduced as the "
"\"Rosette VM\". The choice to use Rosette VM hinged on two factors. First, "
"the Rosette system has been in commercial production for over 20 years. "
"Second, Rosette VM's memory model, model of computation, and runtime systems "
"provide the support for concurrency that RhoVM requires. RChain has pledged "
"to perform a modernized re-implementation of Rosette VM, in Scala, to serve "
"as the initial RhoVM execution environment."
msgstr ""
"RhoVM“执行环境”之后将作为“Rosette VM”引入。选择使用Rosette虚拟机的原因取决于"
"两个因素。首先，Rosette系统已经在生成环境中应用了超过20年。 其次，Rosette VM"
"的内存模型，计算模型和运行时系统为RhoVM所需的并发提供了支持。RChain已经承诺将"
"以Scala语言对Rosette VM进行现代化的重新实现，以作为最初的RhoVM执行环境。"

#: ../../execution_model/rhovm.rst:80
msgid "A Brief Aside on Scalability"
msgstr "可扩展性简介"

#: ../../execution_model/rhovm.rst:82
msgid ""
"From the perspective of a traditional software platform, the notion of "
"“parallel” VM instances is redundant. It is assumed that VM instances "
"operate independently of each other. Accordingly, there is no \"global\" "
"RhoVM. Instead, there is a multiplex of independently operating RhoVM "
"instances running on nodes across the network at any given moment - each "
"executing and validating transactions for their associated shards, or as we "
"have been referring to them, namespaces."
msgstr ""
"从传统软件平台的角度来看，“并发”虚拟机实例的概念是多余的。虚拟机实例都被假设"
"为独立运行。因而，不存在所谓的“全局”的RhoVM虚拟机。相反，在任意给定的时刻，存"
"在多路在跨网络的结点上独立运行的RhoVM，各自在相关的分片(即我们已经提到的命名"
"空间)上执行和验证交易。"

#: ../../execution_model/rhovm.rst:84
msgid ""
"This design choice constitutes system-level concurrency on the RChain "
"platform, where instruction-level concurrency is given by Rholang. Hence, "
"when this publication refers to a single instance of RhoVM, it is assumed "
"that there are a multiplex of RhoVM instances simultaneously executing a "
"different set of contracts for a different namespace."
msgstr ""
"这个设计选择形成了RChain平台上的系统级并发，而指令级的并发由Rholang提供。 因"
"此，当本文引用RhoVM的单个实例时，都假定有多路RhoVM实例同时在不同的命名空间执"
"行不同的合约集合。"

#: ../../execution_model/rhovm.rst:87
msgid "Execution Environment"
msgstr "执行环境"

#: ../../execution_model/rhovm.rst:90
msgid "What Is Rosette?"
msgstr "Rosette是什么？"

#: ../../execution_model/rhovm.rst:92
msgid ""
"Rosette is a reflective, object-oriented language that achieves concurrency "
"via actor semantics. The Rosette system (including the Rosette virtual "
"machine) has been in commercial production since 1994 in Automated Teller "
"Machines. Because of Rosette's demonstrated reliability, RChain Cooperative "
"has committed to completing a clean-room reimplementation of Rosette VM in "
"Scala (targeting the JVM). There are two main benefits of doing so. First, "
"the Rosette language satisfies the instruction-level concurrency semantics "
"expressed in Rholang. Second, Rosette VM was intentionally designed to "
"support a multi-computer (distributed) system operating on an arbitrary "
"number of processors. For more information, see `Mobile Process Calculi for "
"Programming the Blockchain`_."
msgstr ""
"Rosette是一种反射式，面向对象的语言，通过actor语义实现并发。Rosette系统（包括"
"Rosette虚拟机）在1994年已经部署到生成环境中，应用在自动取款机上。 由于Rosette"
"展示出来的可靠性，RChain Cooperative已经承诺会在Scala（针对JVM）完成Rosette "
"VM彻底的重新实现。 这样做有两个主要的好处。 首先，Rosette语言满足Rholang中表"
"达的指令级并发语义。 其次，Rosette VM被有意设计成支持在任意数量的处理器上运行"
"的多计算机（分布式）系统。 有关更多信息，请参阅 `Mobile Process Calculi for "
"Programming the Blockchain`_。"

#: ../../execution_model/rhovm.rst:97
msgid "Model Checking and Theorem Proving"
msgstr "模型校验与理论证明"

#: ../../execution_model/rhovm.rst:99
msgid ""
"In the RhoVM and potentially in upstream contracting languages, there are a "
"variety of techniques and checks that will be applied during compile-time "
"and runtime. These help address requirements such as how a developer and the "
"system itself can know a priori that contracts that are well-typed will "
"terminate. Formal verification will assure end-to-end correctness via model "
"checking (such as in SLMC) and theorem proving (such as in Pro Verif). "
"Additionally, these same checks can be applied during runtime as newly "
"proposed assemblies of contracts are evaluated."
msgstr ""
"在RhoVM和其他潜在的上游合约语言中，有许多技术和检查会被应用在编译时和运行时。"
"这些有助于解决让诸如开发者和系统本身，能够提早知道类型良好的合约将终止的需"
"求。 形式化验证将通过模型检查（如SLMC）和理论证明（如Pro Verif）来确保端到端"
"的正确性。此外，这些相同的检查也可以运行时应用，当新提出组装的合约被运行的时"
"候。"

#: ../../execution_model/rhovm.rst:102
msgid "Discovery Service"
msgstr "发现服务"

#: ../../execution_model/rhovm.rst:104
msgid ""
"An advanced discovery feature that will ultimately be implemented enables "
"searching for compatible contracts and assembling a new composite contract "
"from other contracts. With the formal verification techniques, the author of "
"the new contract can be guaranteed that when working contracts are plugged "
"together they will work as well as a single contract."
msgstr ""
"一个先进的发现特性将最终被实现，从而能够从其他合约中搜索兼容的合约，并合并成"
"一个新的复合合约。通过形式化验证技术，新合约的作者可以得到保证，当工作合约被"
"合并在一起时执行时，与单独合约执行的效果相同。"

#: ../../execution_model/rhovm.rst:107
msgid "Compilation"
msgstr "编译"

#: ../../execution_model/rhovm.rst:109
msgid ""
"To allow clients to execute contracts on the RhoVM, RChain has developed a "
"compiler pipeline that starts with Rholang source-code. Rholang source-code "
"first undergoes transcompilation into Rosette source-code. After analysis, "
"the Rosette source-code is compiled into a Rosette intermediate "
"representation (IRs), which undergoes optimization. From the Rosette IR, "
"Rosette bytecode is synthesized and passed to the VM for local execution. "
"Each translation step within the compilation pipeline is either provably "
"correct, commercially tested in production systems, or both. This pipeline "
"is illustrated in the figure below:"
msgstr ""
"为了允许客户端在RhoVM上执行合约，RChain开发了一个以Rholang源代码为起点的编译"
"器流水线。 Rholang源代码首先经过转译，变成Rosette源代码。经过分析，Rosette源"
"代码被编译成一个Rosette中间状态（IRs），它将被优化。从Rosette IR中，Rosette字"
"节码被合成并传递给VM用于本地执行。编译流水线中的每个转换步骤要么是可证明正确"
"的，要么在生产系统中经过了商业测试，或者两者兼而有之。这个流水线如下图所示："

#: ../../execution_model/rhovm.rst:117
msgid "*Figure - RChain compilation strategy*"
msgstr "*图 - RChain编译策略*"

#: ../../execution_model/rhovm.rst:120
msgid ""
"**Analysis**: From Rholang source-code, or from another smart contract "
"language that compiles to Rholang, this step includes:"
msgstr ""
"**分析**：从Rholang源代码或者编译到Rholang的另一个智能合约语言，这一步包括："

#: ../../execution_model/rhovm.rst:122
msgid "analysis of computational complexity"
msgstr "计算复杂度分析"

#: ../../execution_model/rhovm.rst:123
msgid "injection of code for the rate-limiting mechanism"
msgstr "注入速率限制机制的代码"

#: ../../execution_model/rhovm.rst:124
msgid "formal verification of transaction semantics"
msgstr "事务语义的形式化验证"

#: ../../execution_model/rhovm.rst:125
msgid "desugaring of syntax"
msgstr "解语法糖"

#: ../../execution_model/rhovm.rst:126
msgid "simplification of functional equivalencies"
msgstr "等价函数的简化"

#: ../../execution_model/rhovm.rst:128
msgid "**Transcompilation**: From Rholang source-code, the compiler:"
msgstr "**转译** ：从Rholang的源代码，编译器："

#: ../../execution_model/rhovm.rst:130
msgid ""
"performs a source-to-source translation from Rholang to Rosette source-code."
msgstr "执行从Rholang到Rosette源代码的源代码到源代码的转换。"

#: ../../execution_model/rhovm.rst:132
msgid "**Analysis**: From Rosette source-code, the compiler performs:"
msgstr "**分析** ：从Rosette源代码，编译器执行："

#: ../../execution_model/rhovm.rst:134
msgid ""
"lexical, syntactic, and semantic analysis of the Rosette syntax, "
"construction of the AST; and"
msgstr "依照Rosette语法进行词法、语法和语义分析，构建AST; 和"

#: ../../execution_model/rhovm.rst:135
msgid "synthesizes a Rosette intermediate representation"
msgstr "合称为Rosette中间表示"

#: ../../execution_model/rhovm.rst:137
msgid "**Optimization**: From Rosette IR, the compiler:"
msgstr "**优化**：从Rosette 中间表示(IR)，编译器："

#: ../../execution_model/rhovm.rst:139
msgid ""
"optimizes the IR via redundancy elimination, subexpression elimination, dead-"
"code elimination, constant folding, induction variable identification and "
"strength simplification"
msgstr ""
"通过冗余消除，子表达消除，无用代码消除，常量折叠，变量推理和抢断简化来优化IR"

#: ../../execution_model/rhovm.rst:140
msgid "synthesizes bytecode to be executed by the Rosette VM"
msgstr "合成由Rosette VM执行的字节码"

#: ../../execution_model/rhovm.rst:143
msgid "Rate-limiting Mechanism"
msgstr "限速机制"

#: ../../execution_model/rhovm.rst:145
msgid ""
"The compilation pipeline will implement a rate-limiting mechanism that is "
"related to some calculation of processing, memory, storage, and bandwidth "
"resources. Because the rho-calculus reduction rule is the atomic unit of "
"computation on the RChain platform, the calculation of computation "
"complexity is necessarily correlated to the amount of reductions performed "
"per contract. This mechanism is needed in order to recover costs for the "
"hardware and related operations. Although Ethereum (Gas) has similar needs, "
"the mechanisms are different. Specifically, the metering will not be done at "
"the VM level, but will be injected in the contract code during the analysis "
"phase of compilation."
msgstr ""
"编译器管道将实现一个与处理器，内存，存储和带宽等资源相关的限速机制。由于Rho演"
"算合约归约规则是RChain平台上计算的原子单位，因此计算复杂度的量化必然与每个合"
"约所执行的归约规则数量相关。为了弥补硬件和其他相关操作的成本，这个机制是必须"
"的。 虽然以太坊（Gas）有类似的需求，但机制是不同的。 具体而言，测量将不会在VM"
"这个级别进行，而是在编译的分析阶段注入到合约代码中。"

#: ../../execution_model/rhovm.rst:147
msgid ""
"For more details `join`_ the `#rhovm`_ channel on the RChain Slack here. "
"Compiler work can be seen on `GitHub`_."
msgstr ""
"有关更多详情，请 `加入`_ RChain Slack上的 `#rhovm`_ 频道。 编译器的工作可以"
"在 `GitHub`_ 上看到。"
